import { ChangeDetectionStrategy, Component, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, Optional, Output, ViewEncapsulation } from '@angular/core';
import { CommonModule } from '@angular/common';
import { DomSanitizer } from '@angular/platform-browser';
import { BehaviorSubject as BehaviorSubject$1 } from 'rxjs/BehaviorSubject';
import { timer as timer$1 } from 'rxjs/observable/timer';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { of as of$1 } from 'rxjs/observable/of';
import { combineLatest, delay, distinctUntilChanged, filter, map, skip, switchMap, tap } from 'rxjs/operators';
import { empty as empty$1 } from 'rxjs/observable/empty';
import { map as map$2 } from 'rxjs/operators/map';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgProgressRef {
    /**
     * @param {?} config
     */
    constructor(config) {
        this._state = { active: false, value: 0 };
        /**
         * Stream that increments and updates progress state
         */
        this._trickling$ = new Subject$1();
        /**
         * Stream that emits when progress state is changed
         */
        this.state$ = new BehaviorSubject$1(this._state);
        /**
         * Stream that emits when config is changed
         */
        this.config$ = new Subject$1();
        /**
             * Trickling stream starts the timer that increment the progress bar continuously
             * This stream makes it possible to use latest config values while incrementing
             */
        this._workerSub$ = this._trickling$.pipe(combineLatest(this.config$), switchMap(([start, latestConfig]) => start ? this._trickling(latestConfig) : this._complete(latestConfig))).subscribe();
        this.setConfig(config);
    }
    /**
     * @return {?}
     */
    get isStarted() {
        return this._state.active;
    }
    /**
     * Progress start event
     * @return {?}
     */
    get started() {
        return this.state$.pipe(map((state) => state.active), distinctUntilChanged(), filter(active => active));
    }
    /**
     * Progress ended event
     * @return {?}
     */
    get completed() {
        return this.state$.pipe(map((state) => state.active), distinctUntilChanged(), filter(active => !active), skip(1));
    }
    /**
     * @return {?}
     */
    start() {
        if (!this.isStarted) {
            this.set(this._config.min);
        }
        this._trickling$.next(true);
    }
    /**
     * @return {?}
     */
    complete() {
        if (this.isStarted) {
            this._trickling$.next(false);
        }
    }
    /**
     * @param {?=} amount
     * @return {?}
     */
    inc(amount) {
        let /** @type {?} */ n = this._state.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                if (n >= 0 && n < 20) {
                    amount = 10;
                }
                else if (n >= 20 && n < 50) {
                    amount = 4;
                }
                else if (n >= 50 && n < 80) {
                    amount = 2;
                }
                else if (n >= 80 && n < 99) {
                    amount = 0.5;
                }
                else {
                    amount = 0;
                }
            }
            n = this._clamp(n + amount);
            this.set(n);
        }
    }
    /**
     * @param {?} n
     * @return {?}
     */
    set(n) {
        this._setState({ value: this._clamp(n), active: true });
    }
    /**
     * @param {?} config
     * @return {?}
     */
    setConfig(config) {
        this._config = Object.assign({}, this._config, config);
        this.config$.next(this._config);
    }
    /**
     * Meant to be used internally and not by user directly
     * Users should use NgProgressManager.destroy(id) instead
     * @return {?}
     */
    destroy() {
        this._workerSub$.unsubscribe();
        this._trickling$.unsubscribe();
        this.state$.unsubscribe();
        this.config$.unsubscribe();
    }
    /**
     * @param {?} state
     * @return {?}
     */
    _setState(state) {
        this._state = Object.assign({}, this._state, state);
        this.state$.next(this._state);
    }
    /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    _clamp(n) {
        return Math.max(this._config.min, Math.min(this._config.max, n));
    }
    /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    _trickling(config) {
        return timer$1(0, config.trickleSpeed).pipe(tap(() => this.inc()));
    }
    /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    _complete(config) {
        return of$1({}).pipe(
        // Completes the progress
        tap(() => this._setState({ value: 100 })), 
        // Hides the progress bar after a tiny delay
        delay(config.speed * 1.7), tap(() => this._setState({ active: false })), 
        // Resets the progress state
        delay(config.speed), tap(() => this._setState({ value: 0 })));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const CONFIG = new InjectionToken('config');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const defaultConfig = {
    meteor: true,
    spinner: true,
    thick: false,
    ease: 'linear',
    spinnerPosition: 'right',
    direction: 'ltr+',
    color: '#1B95E0',
    max: 100,
    min: 8,
    speed: 200,
    trickleSpeed: 300
};
class NgProgress {
    /**
     * @param {?} config
     */
    constructor(config) {
        /**
         * Stores NgProgressRef instances
         */
        this._instances = {};
        this.config = Object.assign({}, defaultConfig, config);
    }
    /**
     * Returns NgProgressRef by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    ref(id = 'root', config) {
        if (this._instances[id] instanceof NgProgressRef) {
            return this._instances[id];
        }
        else {
            config = Object.assign({}, this.config, config);
            return this._instances[id] = new NgProgressRef(config);
        }
    }
    /**
     * @param {?} config
     * @param {?=} id
     * @return {?}
     */
    setConfig(config, id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].setConfig(config);
        }
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    start(id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].start();
        }
    }
    /**
     * @param {?} n
     * @param {?=} id
     * @return {?}
     */
    set(n, id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].set(n);
        }
    }
    /**
     * @param {?=} n
     * @param {?=} id
     * @return {?}
     */
    inc(n, id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].inc(n);
        }
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    complete(id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].complete();
        }
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    isStarted(id = 'root') {
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].isStarted : false;
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    started(id = 'root') {
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].started : empty$1();
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    completed(id = 'root') {
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].ended : empty$1();
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    destroy(id = 'root') {
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].destroy();
            this._instances[id] = null;
        }
    }
    /**
     * @return {?}
     */
    destroyAll() {
        Object.keys(this._instances).map((key) => {
            this._instances[key].destroy();
            this._instances[key] = null;
        });
    }
}
NgProgress.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgProgress.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright ngx-progressbar All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/MurhafSousli/ngx-progressbar/blob/master/LICENSE
 */
class NgProgressComponent {
    /**
     * @param {?} _ngProgress
     * @param {?} sanitizer
     */
    constructor(_ngProgress, sanitizer) {
        this._ngProgress = _ngProgress;
        this.sanitizer = sanitizer;
        /**
         * Creates a new instance if id is not already exists
         */
        this.id = 'root';
        /**
         * Initializes inputs from the global config
         */
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.thick = this._ngProgress.config.thick;
        this.max = this._ngProgress.config.max;
        this.min = this._ngProgress.config.min;
        this.speed = this._ngProgress.config.speed;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when input changes
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
            });
        }
        else {
            // Get progress bar service instance
            this.progressRef = this._ngProgress.ref(this.id, {
                max: this.max,
                min: this.min,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
            });
            this.state$ = this.progressRef.state$.pipe(map$2((state) => ({
                active: state.active,
                transform: { transform: `translate3d(${state.value}%, 0, 0)` }
            })));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** Subscribes to started and completed events when user used them */
        if (this.started.observers.length) {
            this._started$ = this.progressRef.started.subscribe(() => this.started.next());
        }
        if (this.completed.observers.length) {
            this._completed$ = this.progressRef.completed.subscribe(() => this.completed.next());
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._started$) {
            this._started$.unsubscribe();
        }
        if (this._completed$) {
            this._completed$.unsubscribe();
        }
        this._ngProgress.destroy(this.id);
    }
    /**
     * @return {?}
     */
    start() {
        this.progressRef.start();
    }
    /**
     * @return {?}
     */
    complete() {
        this.progressRef.complete();
    }
    /**
     * @param {?=} n
     * @return {?}
     */
    inc(n) {
        this.progressRef.inc(n);
    }
    /**
     * @param {?} n
     * @return {?}
     */
    set(n) {
        this.progressRef.set(n);
    }
    /**
     * @return {?}
     */
    get isStarted() {
        return this.progressRef.isStarted;
    }
}
NgProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-progress',
                host: {
                    'role': 'progressbar',
                    '[attr.spinnerPosition]': 'spinnerPosition',
                    '[attr.dir]': 'direction',
                    '[attr.thick]': 'thick',
                    '[attr.style]': `sanitizer.bypassSecurityTrustStyle('--color:' + color + ';--speed:' + speed + 'ms;--ease:' + ease)`
                },
                template: `
    <ng-container *ngIf="state$ | async; let state">
      <div class="ng-progress-bar" [class.-active]="state.active">
        <div class="bar-placeholder">
          <div class="bar" [ngStyle]="state.transform">
            <div *ngIf="meteor" class="meteor"></div>
          </div>
        </div>
        <div *ngIf="spinner" class="spinner">
          <div class="spinner-icon"></div>
        </div>
      </div>
    </ng-container>
  `,
                styles: [`ng-progress {
  z-index: 999999;
  pointer-events: none;
  position: relative; }

.ng-progress-bar {
  z-index: 999999;
  top: 0;
  left: 0;
  width: 100%;
  position: fixed;
  zoom: 1;
  filter: alpha(opacity=0);
  opacity: 0;
  -webkit-transition: opacity var(--speed) var(--ease);
  transition: opacity var(--speed) var(--ease); }
  .ng-progress-bar .bar {
    -webkit-transition: none;
    transition: none; }
  .ng-progress-bar.-active {
    filter: alpha(opacity=100);
    opacity: 1;
    -webkit-transition: none;
    transition: none; }
    .ng-progress-bar.-active .bar {
      -webkit-transition: all var(--speed) var(--ease);
      transition: all var(--speed) var(--ease); }

.bar-placeholder {
  position: absolute;
  height: 2px;
  width: 100%; }

.bar {
  width: 100%;
  height: 100%;
  -webkit-transform: translate(-100%, 0, 0);
          transform: translate(-100%, 0, 0);
  background-color: var(--color); }

.meteor {
  display: block;
  position: absolute;
  width: 100px;
  height: 100%;
  opacity: 1.0;
  -webkit-box-shadow: 0 0 10px var(--color), 0 0 5px var(--color);
          box-shadow: 0 0 10px var(--color), 0 0 5px var(--color); }

.spinner {
  display: block;
  position: fixed;
  z-index: 1031;
  top: 15px; }

.spinner-icon {
  width: 18px;
  height: 18px;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  -webkit-animation: spinner-animation 400ms linear infinite;
          animation: spinner-animation 400ms linear infinite;
  border: 2px solid transparent;
  border-radius: 50%;
  border-top-color: var(--color);
  border-left-color: var(--color); }

[dir='ltr+'] .meteor, [dir='ltr-'] .meteor {
  -webkit-transform: rotate(3deg);
          transform: rotate(3deg); }

[dir='ltr+'][thick='true'] .meteor, [dir='ltr-'][thick='true'] .meteor {
  -webkit-transform: rotate(4deg);
          transform: rotate(4deg); }

[dir='ltr+'] .bar, [dir='rtl+'] .bar {
  margin-left: -100%; }

[dir='ltr+'] .meteor, [dir='rtl+'] .meteor {
  right: 0; }

[dir='ltr+'] .meteor, [dir='rtl-'] .meteor {
  top: -3px; }

[dir='ltr+'][thick='true'] .meteor, [dir='rtl-'][thick='true'] .meteor {
  top: -4px; }

[dir='ltr-'] .meteor, [dir='rtl+'] .meteor {
  bottom: -3px; }

[dir='ltr-'][thick='true'] .meteor, [dir='rtl+'][thick='true'] .meteor {
  bottom: -4px; }

[dir='ltr-'] .bar-placeholder, [dir='rtl+'] .bar-placeholder {
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg); }

[dir='ltr-'] .spinner-icon, [dir='rtl+'] .spinner-icon {
  animation-direction: reverse; }

[dir='rtl+'] .meteor, [dir='rtl-'] .meteor {
  -webkit-transform: rotate(-3deg);
          transform: rotate(-3deg); }

[dir='rtl+'][thick='true'] .meteor, [dir='rtl-'][thick='true'] .meteor {
  -webkit-transform: rotate(-4deg);
          transform: rotate(-4deg); }

[thick='true'] .spinner-icon {
  width: 24px;
  height: 24px;
  border-width: 3px; }

[thick='true'] .bar-placeholder {
  height: 3px; }

[spinnerPosition='left'] .spinner {
  left: 15px;
  right: unset; }

[spinnerPosition='right'] .spinner {
  right: 15px; }

@-webkit-keyframes spinner-animation {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg); }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg); } }

@keyframes spinner-animation {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg); }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg); } }
`],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            },] },
];
/** @nocollapse */
NgProgressComponent.ctorParameters = () => [
    { type: NgProgress, },
    { type: DomSanitizer, },
];
NgProgressComponent.propDecorators = {
    "id": [{ type: Input },],
    "spinnerPosition": [{ type: Input },],
    "direction": [{ type: Input },],
    "ease": [{ type: Input },],
    "color": [{ type: Input },],
    "meteor": [{ type: Input },],
    "spinner": [{ type: Input },],
    "thick": [{ type: Input },],
    "max": [{ type: Input },],
    "min": [{ type: Input },],
    "speed": [{ type: Input },],
    "trickleSpeed": [{ type: Input },],
    "started": [{ type: Output },],
    "completed": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} config
 * @return {?}
 */
function NgProgressFactory(config) {
    return new NgProgress(config);
}
class NgProgressModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: NgProgressModule,
            providers: [
                { provide: CONFIG, useValue: config },
                {
                    provide: NgProgress,
                    useFactory: NgProgressFactory,
                    deps: [CONFIG]
                }
            ]
        };
    }
}
NgProgressModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgProgressComponent],
                exports: [NgProgressComponent],
                imports: [CommonModule]
            },] },
];
/** @nocollapse */
NgProgressModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NgProgressFactory, NgProgressModule, NgProgressComponent, NgProgressRef, NgProgress, CONFIG as Éµa };
//# sourceMappingURL=ngx-progressbar-core.js.map
